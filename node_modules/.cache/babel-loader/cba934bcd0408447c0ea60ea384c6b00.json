{"ast":null,"code":"import{createSelector}from'reselect';import _ from\"lodash\";import TokenTypes from\"../../constants/TokenTypes\";import Wallet from'../../services/Wallet';var getTransactions=function getTransactions(state){return state.transactions.transactions;};var getLocalTransactionsByHash=function getLocalTransactionsByHash(state){return state.transactions.localTransactionsByHash;};var getEthereumNetworkTransactionsByType=function getEthereumNetworkTransactionsByType(state){return state.transactions.ethereumNetworkTransactionsByType;};var getWalletAddress=function getWalletAddress(state){return Wallet.getWalletAddress();};function sortDneroNetworkTransactionOutputs(walletAddress,outputs){return _.sortBy(outputs,[function(output){//Ensure the output we care about is always first\nif(output.address===walletAddress){return-1;}else{return 0;}}]);}function transformDneroNetworkTransaction(walletAddress,transaction){var outputs=transaction.outputs;outputs=sortDneroNetworkTransactionOutputs(walletAddress,outputs);var output=null;var address=null;if(_.isNil(outputs)){//This tx is messed up, return null to prevent breaking the UI\nreturn null;}output=outputs[0];address=output['address'];return Object.assign({},transaction,{bound:walletAddress===address?\"inbound\":\"outbound\",outputs:outputs});}function transformEthereumNetworkTransaction(walletAddress,transaction){return Object.assign({},transaction,{bound:walletAddress===transaction.to?\"inbound\":\"outbound\"});}function getTransformedEthereumNetworkTransactions(walletAddress,type,transactionsByType,localTransactionsByHash){walletAddress=walletAddress?walletAddress.toLowerCase():null;//Merge these transactions and sort by timestamp\nvar scopedTransactions=transactionsByType[type];var txTransformer=_.partial(transformEthereumNetworkTransaction,walletAddress);var transactions=_(scopedTransactions).sortBy(function(tx){return parseInt(tx.time_stamp);}).reverse().map(txTransformer).value();var transactionHashes=new Set(_.map(transactions,function(transaction){return transaction.hash;}));var localTransactions=_.filter(Object.values(localTransactionsByHash),function(transaction){return!transactionHashes.has(transaction.hash)&&transaction[\"type\"]===type;});var allTransactions=_.flatten([localTransactions,transactions]);//Ensure all transactiosn are unique\nreturn _.uniqBy(allTransactions,'hash');}function getTransformedTransactions(walletAddress,txs,localTransactionsByHash){walletAddress=walletAddress?walletAddress.toLowerCase():null;//Merge these transactions and sort by timestamp\nvar isNotNil=_.negate(_.isNil);//returns true if the obj is NOT nil\nvar txTransformer=_.partial(transformDneroNetworkTransaction,walletAddress);var transactions=_(txs).map(txTransformer).filter(isNotNil).sortBy(function(tx){return parseInt(tx.timestamp);}).reverse().value();var transactionHashes=new Set(_.map(transactions,function(transaction){return transaction.hash;}));var localTransactions=_.filter(Object.values(localTransactionsByHash),function(transaction){return!transactionHashes.has(transaction.hash);});var allTransactions=_.flatten([localTransactions,transactions]);//Ensure all transactions are unique\nreturn _.uniqBy(allTransactions,'hash');}export var getERC20Transactions=createSelector([getWalletAddress,getEthereumNetworkTransactionsByType,getLocalTransactionsByHash],function(walletAddress,transactionsByType,localTransactionsByHash){return getTransformedEthereumNetworkTransactions(walletAddress,TokenTypes.ERC20_DNERO,transactionsByType,localTransactionsByHash);});export var getEthereumTransactions=createSelector([getWalletAddress,getEthereumNetworkTransactionsByType,getLocalTransactionsByHash],function(walletAddress,transactionsByType,localTransactionsByHash){return getTransformedEthereumNetworkTransactions(walletAddress,TokenTypes.ETHEREUM,transactionsByType,localTransactionsByHash);});export var getDneroNetworkTransactions=createSelector([getWalletAddress,getTransactions,getLocalTransactionsByHash],function(walletAddress,transactions,localTransactionsByHash){return getTransformedTransactions(walletAddress,transactions,localTransactionsByHash);});","map":{"version":3,"names":["createSelector","_","TokenTypes","Wallet","getTransactions","state","transactions","getLocalTransactionsByHash","localTransactionsByHash","getEthereumNetworkTransactionsByType","ethereumNetworkTransactionsByType","getWalletAddress","sortDneroNetworkTransactionOutputs","walletAddress","outputs","sortBy","output","address","transformDneroNetworkTransaction","transaction","isNil","Object","assign","bound","transformEthereumNetworkTransaction","to","getTransformedEthereumNetworkTransactions","type","transactionsByType","toLowerCase","scopedTransactions","txTransformer","partial","tx","parseInt","time_stamp","reverse","map","value","transactionHashes","Set","hash","localTransactions","filter","values","has","allTransactions","flatten","uniqBy","getTransformedTransactions","txs","isNotNil","negate","timestamp","getERC20Transactions","ERC20_DNERO","getEthereumTransactions","ETHEREUM","getDneroNetworkTransactions"],"sources":["/Users/jjestrella/DNERO_Protocol/dnerowebwallet/src/state/selectors/Transactions.js"],"sourcesContent":["import {createSelector} from 'reselect'\nimport _ from \"lodash\";\nimport TokenTypes from \"../../constants/TokenTypes\";\nimport Wallet from '../../services/Wallet'\n\nconst getTransactions = (state) => state.transactions.transactions;\nconst getLocalTransactionsByHash = (state) => state.transactions.localTransactionsByHash;\n\nconst getEthereumNetworkTransactionsByType = (state) => state.transactions.ethereumNetworkTransactionsByType;\n\nconst getWalletAddress = (state) => Wallet.getWalletAddress();\n\nfunction sortDneroNetworkTransactionOutputs(walletAddress, outputs){\n    return _.sortBy(outputs, [function (output) {\n        //Ensure the output we care about is always first\n        if (output.address === walletAddress) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }]);\n}\n\nfunction transformDneroNetworkTransaction(walletAddress, transaction) {\n    let {outputs} = transaction;\n    outputs = sortDneroNetworkTransactionOutputs(walletAddress, outputs);\n\n    let output = null;\n    let address = null;\n\n    if (_.isNil(outputs)) {\n        //This tx is messed up, return null to prevent breaking the UI\n        return null;\n    }\n\n    output = outputs[0];\n    address = output['address'];\n\n    return Object.assign({}, transaction, {\n        bound: (walletAddress === address ? \"inbound\" : \"outbound\"),\n        outputs: outputs\n    });\n}\n\nfunction transformEthereumNetworkTransaction(walletAddress, transaction) {\n    return Object.assign({}, transaction, {bound: (walletAddress === transaction.to ? \"inbound\" : \"outbound\")});\n}\n\nfunction getTransformedEthereumNetworkTransactions(walletAddress, type, transactionsByType, localTransactionsByHash) {\n    walletAddress = (walletAddress ? walletAddress.toLowerCase() : null);\n\n    //Merge these transactions and sort by timestamp\n    let scopedTransactions = transactionsByType[type];\n    let txTransformer = _.partial(transformEthereumNetworkTransaction, walletAddress);\n    let transactions = _(scopedTransactions)\n        .sortBy(tx => parseInt(tx.time_stamp))\n        .reverse()\n        .map(txTransformer)\n        .value();\n    let transactionHashes = new Set(_.map(transactions, function (transaction) {\n        return transaction.hash;\n    }));\n    let localTransactions = _.filter(Object.values(localTransactionsByHash), function (transaction) {\n        return !transactionHashes.has(transaction.hash) && transaction[\"type\"] === type;\n    });\n\n    let allTransactions = _.flatten([localTransactions, transactions]);\n\n    //Ensure all transactiosn are unique\n    return _.uniqBy(allTransactions, 'hash')\n}\n\nfunction getTransformedTransactions(walletAddress, txs, localTransactionsByHash) {\n    walletAddress = (walletAddress ? walletAddress.toLowerCase() : null);\n\n    //Merge these transactions and sort by timestamp\n    let isNotNil = _.negate(_.isNil);//returns true if the obj is NOT nil\n    let txTransformer = _.partial(transformDneroNetworkTransaction, walletAddress);\n    let transactions = _(txs)\n        .map(txTransformer)\n        .filter(isNotNil)\n        .sortBy(tx => parseInt(tx.timestamp))\n        .reverse()\n        .value();\n    let transactionHashes = new Set(_.map(transactions, function (transaction) {\n        return transaction.hash;\n    }));\n    let localTransactions = _.filter(Object.values(localTransactionsByHash), function (transaction) {\n        return !transactionHashes.has(transaction.hash);\n    });\n\n    let allTransactions = _.flatten([localTransactions, transactions]);\n\n    //Ensure all transactions are unique\n    return _.uniqBy(allTransactions, 'hash')\n}\n\nexport const getERC20Transactions = createSelector(\n    [getWalletAddress, getEthereumNetworkTransactionsByType, getLocalTransactionsByHash],\n    (walletAddress, transactionsByType, localTransactionsByHash) => {\n        return getTransformedEthereumNetworkTransactions(walletAddress, TokenTypes.ERC20_DNERO, transactionsByType, localTransactionsByHash);\n    }\n);\n\nexport const getEthereumTransactions = createSelector(\n    [getWalletAddress, getEthereumNetworkTransactionsByType, getLocalTransactionsByHash],\n    (walletAddress, transactionsByType, localTransactionsByHash) => {\n        return getTransformedEthereumNetworkTransactions(walletAddress, TokenTypes.ETHEREUM, transactionsByType, localTransactionsByHash);\n    }\n);\n\nexport const getDneroNetworkTransactions = createSelector(\n    [getWalletAddress, getTransactions, getLocalTransactionsByHash],\n    (walletAddress, transactions, localTransactionsByHash) => {\n        return getTransformedTransactions(walletAddress, transactions, localTransactionsByHash);\n    }\n);"],"mappings":"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"},"metadata":{},"sourceType":"module"}